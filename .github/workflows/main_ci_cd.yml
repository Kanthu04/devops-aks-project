name: CI/CD Pipeline to Local K8s (Simulated)

# Trigger the workflow on every push to the main branch
on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    # Use the latest Ubuntu runner hosted by GitHub
    runs-on: ubuntu-latest
    steps:
      - name: 1. Checkout Code (Get files from GitHub)
        uses: actions/checkout@v4

      - name: 2. Set up Docker BuildX (Prerequisite for building)
        uses: docker/setup-buildx-action@v3

      # --- Simulate Registry Login/Push (Required for CI/CD flow) ---
      - name: 3. Login to Dummy Docker Registry
        uses: docker/login-action@v3
        with:
          # Uses the secrets you created (ci_cd_user, ci_cd_token)
          username: ${{ secrets.DOCKER_USERNAME }} 
          password: ${{ secrets.DOCKER_PASSWORD }} 

      # - name: 4. Build Docker Image (Using Dockerfile)
      #   # Use the same image name/tag as your K8s deployment.yaml
      #   run: docker build -t static-web-app:v1 .
      # NEW Step 4: Use the reliable internal KinD tag format
      - name: 4. Build Docker Image (Using Dockerfile)
        run: docker build -t localhost:5000/static-web-app:v1 .

      - name: 5. Simulate Push (Image built successfully, ready for deploy)
        run: echo "Image built and push to local cache is simulated."
      # Replace the entire block starting with - name: 6. Build KinD Cluster, Load and Deploy with the following:

      - name: 6. Setup KinD Cluster and Load Image
        uses: helm/kind-action@v1.10.0
        with:
          # Tell KinD to use the configuration file created in Step 1
          config: kind-config.yaml
          
          # Load the image you just built
          image: static-web-app:v1

      # - name: 7. Apply Kubernetes Manifests
      #   run: |
      #     kubectl apply -f k8s/deployment.yaml
      #     kubectl apply -f k8s/service.yaml
      # NEW Step 7: Patch the deployment file before applying it
      # - name: 7. Apply Kubernetes Manifests (with updated image tag)
      #   run: |
      #     # Use sed to replace the old image name with the new localhost:5000 tag
      #     sed -i 's|image: static-web-app:v1|image: localhost:5000/static-web-app:v1|g' k8s/deployment.yaml
      #     kubectl apply -f k8s/deployment.yaml
      #     kubectl apply -f k8s/service.yaml
      # NEW Step 7: Use kubectl set image and apply service separately
      # - name: 7. Apply Kubernetes Manifests and Patch ImagePullPolicy
      #   run: |
      #     # 1. Apply the service (must be done first, as it's static)
      #     kubectl apply -f k8s/service.yaml
          
      #     # 2. Apply the deployment (This creates the resource with the old image tag)
      #     kubectl apply -f k8s/deployment.yaml

      #     # 3. Patch the deployment with the correct local image tag and force pull policy.
      #     # We use the deployment name and container name directly.
      #     kubectl set image deployment/static-web-deployment static-web-container=localhost:5000/static-web-app:v1
      #     kubectl patch deployment static-web-deployment --patch '{"spec": {"template": {"spec": {"containers": [{"name": "static-web-container", "imagePullPolicy": "Never"}]}}}}'
          
      # # NEW Step 8: Increase timeout to 120s
      # - name: 8. Deployment Verification
      #   run: |
      #     echo "Waiting for pod readiness..."
      #     kubectl rollout status deployment/static-web-deployment --timeout=120s # Increased timeout
      #     kubectl get pods
      #     kubectl get svc
      # NEW STEP 6.5: Aggressively delete the deployment immediately after KinD is up.
      - name: 6.5 Aggressively Delete Previous Deployment
        run: |
          # Use a loop to wait briefly and aggressively delete old resources
          kubectl delete deployment static-web-deployment --ignore-not-found=true --grace-period=0 --force
          kubectl delete service static-web-service --ignore-not-found=true

      # Step 7 is now much cleaner, applying the manifests to a clean slate.
      - name: 7. Apply Kubernetes Manifests and Patch ImagePullPolicy
        run: |
          # 1. Delete and apply commands remain the same, ensuring resources exist
          kubectl delete deployment static-web-deployment --ignore-not-found=true --grace-period=0 --force
          kubectl delete service static-web-service --ignore-not-found=true
          kubectl apply -f k8s/service.yaml
          kubectl apply -f k8s/deployment.yaml
          
          # 2. Patch the deployment with the image and pull policy
          kubectl set image deployment/static-web-deployment static-web-container=localhost:5000/static-web-app:v1
          kubectl patch deployment static-web-deployment -p '{"spec": {"template": {"spec": {"containers": [{"name": "static-web-container", "imagePullPolicy": "Never"}]}}}}'

      # NEW STEP 7.5: Force Rolling Restart (The final push)
      - name: 7.5 Force Rolling Restart
        run: |
          # The "touch" command updates an annotation, forcing Kubernetes to create a brand new pod instantly.
          kubectl rollout restart deployment/static-web-deployment
          sleep 10 # Wait 10 seconds for the rollout to begin

      - name: 8. Deployment Verification
        run: |
          echo "Waiting for pod readiness..."
          # The timeout of 120s is fine, but this command will wait for the new pod to start.
          kubectl rollout status deployment/static-web-deployment --timeout=120s 
          kubectl get pods
          kubectl get svc